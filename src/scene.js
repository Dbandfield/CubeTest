import React, { Component } from 'react';
import * as THREE from 'three';
import OrbitControls from 'three-orbitcontrols';
import CameraIcon from './img/camera.svg';
import { GUI, Button } from './gui.js';

/**
 * This script handes the 3D scene.
 * The GUI is also imported, and displayed over the top.
 * 
 * The are 2 main classes here.
 * 
 * Cube represents a cube within the scene and various 
 * behaviours associated with it.
 * 
 * ThreeScene derives from React Component and is where
 * the scene is built and managed.
 */


 /**
  * Class Cube
  * When creating, specify _maxDistance
  * as the maximum size of the cube-space within
  * which the cube may appear randomly.
  * 
  * Pass the scene object to which it is to be 
  * added and the name of the cube to identify it.
  */
class Cube
{
  constructor(_maxDistance, _scene, _name)
  {
    this.scene = _scene;
    this.name = _name;

    // There are two colours associated with
    // the cube. 
    // Its regular colour is assigned randomly
    // on creation, or set via the GUI.
    // the 'select colour' is generated by taking
    // the HSL of the regular colour and increasing 
    // the 'L' element. It display when the cube 
    // is selected
    this.colour = new THREE.Color();
    this.selectColour = new THREE.Color();

    // use HSL for prettier randomness
    this.colour.setHSL(Math.random(), 1, 0.5);

    var hsl = {h:0, s:0, l:0};
    this.colour.getHSL(hsl);
    this.selectColour.setHSL(hsl.h, hsl.s, 0.9);

    // No need for lots of polygons at the moment, so
    // segements is set to 1
    const cubeSize = 10;
    var geo = new THREE.CubeGeometry(cubeSize, cubeSize, cubeSize, 1, 1);
    this.material = new THREE.MeshLambertMaterial({color: this.colour});
    this.mesh = new THREE.Mesh(geo, this.material);


    // Generate random position

    // Specify an interval between potential
    // positions to avoid cube collisions
    var randomInterval = cubeSize + 5;
    // work out how may intervals per specified max distance
    var randomSteps = Math.floor(_maxDistance/randomInterval);

    // This is to extend max distance in negative directions as well
    var ranX = (Math.random() * 2.0) - 1.0;
    var ranY = (Math.random() * 2.0) - 1.0;
    var ranZ = (Math.random() * 2.0) - 1.0;

    ranX = (ranX * randomSteps) * randomInterval;
    ranY = (ranY * randomSteps) * randomInterval;
    ranZ = (ranZ * randomSteps) * randomInterval;

    this.mesh.position.set(ranX, ranY, ranZ);
    this.scene.add(this.mesh);

    this.selected = false;
  }

  getName()
  {
    return this.name;
  }

  getMesh()
  {
    return this.mesh;
  }

  resetScale()
  {
    this.setScale(1);
  }

  selectCube()
  {
    this.selected = true;
    this.material.setValues({color: this.selectColour});
  }

  deselectCube()
  {
    this.selected = false;
    this.material.setValues({color: this.colour});
  }

  /**
   * _value is a number to scale the cube by. 1 is
   * the original scale.
   * 
   * @param {number} _value 
   */
  setScale(_value)
  {
    this.mesh.scale.set(_value, _value, _value);
  }

  /**
   * Provide an object with 3 numbers named
   * r, g and b
   * 
   * The colour picker I am using is easier to
   * convert to Three's system via RGB.
   * 
   * However, a little bit of HSL conversion is done
   * here so that it is easier to work out the 
   * 'select' colour.
   * 
   * @param {object} _rgb 
   */
  setColour(_rgb)
  {
    this.colour.setRGB(_rgb.r/255, _rgb.g/255, _rgb.b/255);
    var hsl = {h:0, s:0, l:0};
    this.colour.getHSL(hsl);
    this.selectColour.setHSL(hsl.h, hsl.s, 0.7);

    if(this.selected)
    {
      this.material.setValues({color: this.selectColour});
    }
    else
    {
      this.material.setValues({color: this.colour});
    }

  }

  /**
   * Call this before removing to tidy up.
   */
  deconstruct()
  {
        this.scene.remove(this.mesh);
  }
}

/**
 * Class ThreeScene
 * 
 * A React componenent which also sets up and 
 * handles the 3D scene. It also renders the GUI
 * using the imported class.
 */
class ThreeScene extends Component 
{
  constructor(props) 
  {
    super(props)

    /* To allow proper animation from
    within React */
    this.start = this.start.bind(this)
    this.stop = this.stop.bind(this)
    this.animate = this.animate.bind(this)

    /** React state 
     * selectedName: name of selected Cube
     * selectedNumber: number of selected cube.
     *    note that this one more than the 
     *    index used within the code, because
     *    0 based indices will look weird to the user.
     * cubesExist: indicates if there are cubes
     *    so the GUI can indicate this.
     * delMsg: the cube-specific delete message string
    */
    this.state = {selectedName: '', 
                  selectedNumber: '',
                  cubesExist: false,
                  delMsg: ''};

    // arbitrary maximum
    this.MAX_CUBES = 20;
  }

  componentDidMount() 
  {
    // three basics
    this.scene = null;
    this.camera = null;
    this.renderer = null;
    this.light = null;

    /** cube indentifiers. This is cycled through in a 
     * circular fashion, so once it gets to the end
     * cube names may not be unique.
     */
    
    this.cubeNames = 
    [
      'Vincent', 'Jules', 'Mia', 'Butch', 'Winston', 
      'Ringo', 'Yolanda', 'Fabienne', 'Marsellus', 'Marvin',
      'Brett', 'Roger', 'Lance', 'Jimmie', 'Jody'
    ]

    // current index in the above array
    this.nextName = 0;

    // scene setup code is in here
    this.setupScene();

    /** The cubes. The reason for two
      separate arrays is that the raycaster
      needs an array of Object3Ds to query,
      but cube functionality is easier if
      the meshes are normally stored in a 
      custom class.
    **/
    this.cubes = 
    {
      meshes: [],
      objects: []
    }

    /** The index in the above arrays for the currently
     * selected cube. It should always be set to null
     * when there are no more cubes. Always test
     * specifically for null rather than just falsiness,
     * because 0 equates to false yet is a valid value.
     */ 
    this.selectedCube = null;

    // controls 
    this.controls = new OrbitControls(this.camera, this.mount);

    /** The screen position of the mouse and a raycaster
    * (used for cube selection)
    */
    this.mouse = new THREE.Vector2();
    this.raycaster = new THREE.Raycaster();

    /** Generate  a single cube to start. This is the same fn 
    * called in response to the user pressing the new 
    * cube button
    */
    this.newCube();

    /** Event listeners for mouse clicking(for cube selection)
     * and window resizing
     */
    document.addEventListener( 'mousedown', (_e)=>{this.onDocumentMouseDown(_e)}, false );
    document.addEventListener( 'touchstart', (_e)=>{this.onDocumentTouchStart(_e)}, false );
    window.addEventListener('resize', ()=>{this.onWindowResize()}, false);

    /* Start the animation cycle! */
    this.start();
  }

  /* Cleanup when removed */
  componentWillUnmount() 
  {
    this.stop()
    this.mount.removeChild(this.renderer.domElement)
  }

  /* Make sure renderer updates properly when window is resized */
  onWindowResize()
  {
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();

    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }

  /* Registered as event listener */
  onDocumentTouchStart(_event) 
  {
    _event.preventDefault();

    _event.clientX = _event.touches[0].clientX;
    _event.clientY = _event.touches[0].clientY;
    onDocumentMouseDown(event);
  }

  /** Registered as an event listener and 
   * called when mouse is clicked. Works out 
   * if the mouse is over a cube.
   */
  onDocumentMouseDown(_event) 
  {

    this.mouse.x = (_event.clientX / this.renderer.domElement.clientWidth ) * 2 - 1;
    this.mouse.y = - (_event.clientY / this.renderer.domElement.clientHeight ) * 2 + 1;

    this.raycaster.setFromCamera(this.mouse, this.camera );

    /** Note, the cube meshes are created in the Cube objects,
     *  But are also referenced directly in the meshes array.
     *  This is so the raycaster can query them.
     */
    var intersects = this.raycaster.intersectObjects(this.cubes.meshes);

    if (intersects.length > 0) 
    {

      for(var m in this.cubes.meshes)
      {
        if(this.cubes.meshes[m] == intersects[0].object)
        {
          this.selectedCube = m;
          this.cubes.objects[m].selectCube();
          this.updateSelectedText();
          this.updateDeleteText();
        }
        else
        {
          this.cubes.objects[m].deselectCube();
        }
      }

    }
  }

  /* Begin animation loop */
  start() 
  {
    if (!this.frameId) 
    {
      this.frameId = requestAnimationFrame(this.animate)
    }
  }

  /* Stop animation loop */
  stop() 
  {
    cancelAnimationFrame(this.frameId)
  }

  /* Actual animation code */
  animate() 
  {
    this.controls.update();
    this.renderScene()
    this.frameId = window.requestAnimationFrame(this.animate)
  }

  renderScene() 
  {
    this.renderer.render(this.scene, this.camera)
  }

  /** The text that asks if the user really wants 
   * to delete a cube needs to reflect the name of 
   * the currently selected cube
   */
  updateDeleteText()
  {
    if(this.selectedCube != null)
    {

      var str = "Are you sure you would like to delete " + 
          this.cubes.objects[this.selectedCube].getName();
      this.setState({delMsg: str});
    }
  }

  /**
   * The text displaying the currently selected cube name needs
   * to be updated when a new unit is selected.
   */
  updateSelectedText()
  {
    var nameStr;
    var numberStr;

    if(this.selectedCube != null)
    {
      var humanIndex = parseInt(this.selectedCube) + 1;
      nameStr = this.cubes.objects[this.selectedCube].getName();
      numberStr = 'Cube ' + humanIndex + ' of ' +
                this.cubes.objects.length;
      this.setState({selectedName: nameStr});
      this.setState({selectedNumber: numberStr});
    }
    else
    {
      nameStr = "Press the plus to create a cube";
      this.setState({selectedName: nameStr})
      this.setState({selectedNumber: ''});
    }
  }

  /**
   * Called on setup and also when user requests 
   * camera reset.
   */
  setInitialCameraPos()
  {
    this.camera.position.set(0, 50, 20);
  }

  /**
   * ThreeJS setup
   */
  setupScene()
  {
    const width = window.innerWidth;
    const height= window.innerHeight;

    this.scene = new THREE.Scene()
    this.camera = new THREE.PerspectiveCamera(
      75,
      width / height,
      0.1,
      1000
    )

    this.setInitialCameraPos();

    this.renderer = new THREE.WebGLRenderer({ antialias: true })

    this.renderer.setClearColor('#000000')
    this.renderer.setSize(width, height)
    // To make it work with react
    this.mount.appendChild(this.renderer.domElement)

    // the light
    this.light = new THREE.HemisphereLight(0xffffff, 0x112255, 1);
    this.light.position.set(0.5, 1, 0.75);
    this.scene.add(this.light);
  }

  /**
   * Add a new cube to the scene. Call from GUI and
   * also on setup.
   */
  newCube()
  {
    if(this.cubes.objects.length < this.MAX_CUBES)
    {
      /**
       * 200 is the size of the bounding cube where the Cube object is allowed to spawn
       */
      const l = this.cubes.objects.push(new Cube(200, this.scene, this.cubeNames[this.nextName]));
      this.nextName ++;
      if(this.nextName >= this.cubeNames.length) this.nextName = 0;
      this.cubes.meshes.push(this.cubes.objects[l -1].getMesh());
      this.selectedCube = l - 1;
      this.updateSelectedText();
      this.updateDeleteText();

      this.setState({cubesExist: true});
    }
  }

  /**
   * Passed to GUI as callback to scale the 
   * currently selected cube.
   * 
   * @param {number} _value 
   */
  scaleCube(_value)
  {
    if(this.selectedCube != null) 
    {
      this.cubes.objects[this.selectedCube].setScale(_value);
    }
  }

  /**
   * Passed to GUI as callback to change colour
   * of currently selected cube.
   * 
   * _colour is an object with the members:
   * r, g and b
   * which are numbers between 0 and 255
   * 
   * @param {object} _colour 
   */
  onNewColour(_colour)
  {
    if(this.selectedCube != null) 
    {
      this.cubes.objects[this.selectedCube].setColour(_colour.rgb);
    }
  }

  /**
   * Passed to GUI as callback to set currently selected
   * cube's scale to 1.
   */
  resetScale()
  {
    if(this.selectedCube != null) 
    {
      this.cubes.objects[this.selectedCube].resetScale();
    }
  }

  /** Passed to GUI as callback to delete currently 
   * selected cube.
   */
  onDelete()
  {
    if(this.selectedCube != null)
    {
      // remove cube from array
      this.cubes.objects[this.selectedCube].deconstruct();
      this.cubes.objects.splice(this.selectedCube, 1);
      this.cubes.meshes.splice(this.selectedCube, 1);

      if(this.cubes.objects.length <= 0)
      {
        this.selectedCube = null;
        this.setState({cubesExist: false});
      }
      else
      {
        this.selectedCube = 0;
      }
    }

    this.updateSelectedText();
    this.updateDeleteText();
  }

  /* Render the React componenets */
  render() 
  {
    /**
     * To avoid having a big DOM element
     * stretched between the sidebar and 
     * the camera reset button, the camera
     * button is separated from the rest of the
     * GUI.
     * 
     * Previously, the DOM element that acted 
     * as a container for all GUI elements
     * prevented selecting cubes.
     * 
     * TODO: Solve this more elegantly
     */
    return (
      <div className='scene'>
        <GUI 
                // STATE
                delMsg={this.state.delMsg} 
                name={this.state.selectedName}
                number={this.state.selectedNumber}
                cubesExist={this.state.cubesExist}

                // CALLBACKS
                onNewCube={() => this.newCube()} 
                onSlider={(_val) => {this.scaleCube(_val)}}
                onNewColour={(_col) => {this.onNewColour(_col)}} 
                onDelete={() => {this.onDelete()}}
                onResetCam={() => {this.setInitialCameraPos()}}
                resetScale={() => {this.resetScale()}}
          />
              
        <div className='camera background'>
          <Button img={CameraIcon} onClick={() =>{this.setInitialCameraPos()}} />
        </div>
        <div
          ref={(mount) => { this.mount = mount }}
        />
      </div>
    )
  }
}

/**
 * Utility functions for all classes
 */

function degToRad(_deg)
{
    return _deg * (Math.PI / 180);
} 

function radTodeg(_rad)
{
    return _rad * (180 / Math.PI);
}

export default ThreeScene